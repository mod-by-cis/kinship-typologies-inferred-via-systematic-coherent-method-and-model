/** @jsxRuntime automatic */
/** @jsxImportSource https://esm.sh/preact@10.26.8 */
import { JSX } from "https://esm.sh/preact@10.26.8";

// Definicje typów (powtórzone dla samodzielności komponentu, jeśli jest w osobnym pliku)
type NestedNumberArray = number | NestedNumberArray[];
type ExcelResults = Map<string, NestedNumberArray>;

interface PlotExcelProps {
  /** Mapa zawierająca dane do wyświetlenia. Klucze to nazwy serii (nagłówki), wartości to dane. */
  data: ExcelResults;
  /** Orientacja tabeli: 'col' (dane w kolumnach) lub 'row' (dane w wierszach). */
  type: 'col' | 'row';
  /** Opcjonalna klasa CSS dla elementu <table>. */
  tableClassName?: string;
  /** Opcjonalna klasa CSS dla elementów <th>. */
  thClassName?: string;
  /** Opcjonalna klasa CSS dla elementów <td>. */
  tdClassName?: string;
  /** Opcjonalne style inline dla tabeli */
  tableStyle?: JSX.CSSProperties;
  /** Opcjonalne style inline dla komórek nagłówkowych */
  thStyle?: JSX.CSSProperties;
  /** Opcjonalne style inline dla komórek danych */
  tdStyle?: JSX.CSSProperties;
}

/**
 * Komponent do wyświetlania danych z Mapy (ExcelResults) w formie tabeli.
 * Pozwala na orientację kolumnową ('col') lub wierszową ('row').
 */
export function PlotExcel({
  data,
  type,
  tableClassName,
  thClassName,
  tdClassName,
  tableStyle,
  thStyle,
  tdStyle,
}: PlotExcelProps): JSX.Element | null {
  if (!data || data.size === 0) {
    return null; // Nie renderuj nic, jeśli nie ma danych
  }

  const keys = Array.from(data.keys()); // Nazwy serii danych (np. "i", "floor(log₂(i))")

  // Ustal maksymalną długość (liczbę elementów) wśród wszystkich serii danych.
  // To ważne dla prawidłowego renderowania wszystkich komórek.
  let maxLength = 0;
  data.forEach(value => {
    if (Array.isArray(value)) {
      // Na razie zakładamy, że są to płaskie tablice liczb.
      // Jeśli NestedNumberArray może być głębiej zagnieżdżone i chcemy to uwzględnić,
      // potrzebna byłaby rekurencyjna funkcja do obliczenia "efektywnej" długości.
      let currentLength = 0;
      const checkLength = (arr: NestedNumberArray) => {
        if (Array.isArray(arr)) {
          if (arr.length > 0 && !Array.isArray(arr[0])) { // Płaska tablica liczb/stringów
             currentLength = Math.max(currentLength, arr.length);
          } else { // Potencjalnie zagnieżdżona lub pusta
            arr.forEach(checkLength); // Rekurencyjne sprawdzenie dla zagnieżdżonych (uproszczone)
          }
        } else {
          currentLength = Math.max(currentLength, 1); // Skalar traktujemy jako długość 1
        }
      };
      checkLength(value);
      maxLength = Math.max(maxLength, currentLength);

    } else { // Skalar
      maxLength = Math.max(maxLength, 1);
    }
  });
  
  // Jeśli wszystkie wpisy są skalarami (lub pustymi tablicami, ale są klucze), maxLength to 1.
  if (maxLength === 0 && keys.length > 0) {
      maxLength = 1;
  }


  // Funkcja pomocnicza do pobierania wartości z NestedNumberArray dla danego indeksu.
  // Dla uproszczenia, jeśli jest to zagnieżdżona tablica, zwraca jej reprezentację string.
  const getValueAtIndex = (value: NestedNumberArray, index: number): string | number | null => {
    if (Array.isArray(value)) {
      if (index < value.length) {
        const item = value[index];
        if (typeof item === 'number' || typeof item === 'string') {
          return item;
        } else if (Array.isArray(item)) { // Jeśli element sam jest tablicą
          return `[${item.join(', ')}]`; // Prosta reprezentacja stringowa
        }
        return String(item); // Dla innych typów, np. głębiej zagnieżdżonych
      }
      return null; // Poza zakresem
    }
    // Jeśli to skalar, wyświetl go tylko dla pierwszego indeksu (w kontekście tabeli)
    return index === 0 ? value : null;
  };

  if (type === 'col') {
    // Orientacja KOLUMNOWA:
    // Klucze z mapy są nagłówkami kolumn.
    // Wiersze są indeksowane od 0 do maxLength - 1.
    // Przykład:
    // Klucz1    | Klucz2
    // --------------------
    // wartość1[0] | wartość2[0]
    // wartość1[1] | wartość2[1]
    // ...
    return (
      <table className={tableClassName} style={tableStyle}>
        <thead>
          <tr>
            {keys.map(key => (
              <th key={key} className={thClassName} style={thStyle}>{key}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {Array.from({ length: maxLength }).map((_, rowIndex) => (
            <tr key={`row-${rowIndex}`}>
              {keys.map(key => {
                const valueSet = data.get(key);
                // Domyślnie 'valueSet' nie powinno być undefined, bo 'key' pochodzi z 'data.keys()'
                const cellValue = valueSet !== undefined ? getValueAtIndex(valueSet, rowIndex) : null;
                return (
                  <td key={`${key}-row-${rowIndex}`} className={tdClassName} style={tdStyle}>
                    {cellValue !== null ? String(cellValue) : ''}
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </table>
    );
  } else { // type === 'row'
    // Orientacja WIERSZOWA (transponowana):
    // Klucze z mapy są nagłówkami wierszy (w pierwszej kolumnie).
    // Kolumny danych są indeksowane od 0 do maxLength - 1.
    // Przykład:
    // Klucz1    | wartość1[0] | wartość1[1] | ...
    // Klucz2    | wartość2[0] | wartość2[1] | ...
    return (
      <table className={tableClassName} style={tableStyle}>
        <tbody>
          {keys.map(key => {
            const valueSet = data.get(key);
            return (
              <tr key={key}>
                <th scope="row" className={thClassName} style={{ textAlign: 'left', ...thStyle }}>{key}</th>
                {Array.from({ length: maxLength }).map((_, colIndex) => {
                  const cellValue = valueSet !== undefined ? getValueAtIndex(valueSet, colIndex) : null;
                  return (
                    <td key={`${key}-col-${colIndex}`} className={tdClassName} style={tdStyle}>
                      {cellValue !== null ? String(cellValue) : ''}
                    </td>
                  );
                })}
              </tr>
            );
          })}
        </tbody>
      </table>
    );
  }
}
