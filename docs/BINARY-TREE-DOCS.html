<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Matematyka w genealogii</title>
  <style>
    :root {
      --bg: oklch(0.92 0.022 260.12);
      --bg-math: oklch(0.97 0.022 260.12);
      --text: oklch(0.12 0.022 260.12);
      --graf-ih0: oklch(0.69 0.1388 355);
      --graf-ih1: oklch(0.69 0.1388 70);
      --graf-ih2: oklch(0.69 0.1388 112);
      --graf-ih3: oklch(0.69 0.1388 150);
      --math-border: oklch(0.92 0.052 260.12);
      --math-tt: black;
      --math-ih: firebrick;
      --math-jh: darkgoldenrod;
      --math-i: mediumblue;
      --math-j: royalblue;
      --math-mix: darkorchid;
      --math-j-sort: mediumpurple;
      --math-jh-sort: sienna;
      --math-to-fam: lightseagreen;
    }

    body {
      background-color: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
      padding: 2rem;
      line-height: 1.6;
    }

    html, body {
       min-width: 800px;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: oklch(0.42 0.082 260.12);
    }

    .math-box {
      background-color: var(--bg-math);
      padding: 1.5rem;
      border-radius: 2rem;
      border: 0.2rem double var(--math-border);
    }

    .ih {
      color: var(--math-ih);
      font-weight: bold;
    }

    .i {
      color: var(--math-i);
      font-weight: bold;
    }    

    .jh {
      color: var(--math-jh);
      font-weight: bold;
    }

    .j {
      color: var(--math-j);
      font-weight: bold;
    }   

    .jhsort {
      color: var(--math-jh-sort);
      font-weight: bold;
    }

    .jsort {
      color: var(--math-j-sort);
      font-weight: bold;
    }

    .mix {
      color: var(--math-mix);
      font-weight: bold;
    }

    .tt {
      color: var(--math-tt);
      font-weight: bold;
    }

    .bg-ih0 {
      background-color: var(--graf-ih0);
    }

    .bg-ih2 {
      background-color: var(--graf-ih2);
    }

    .bg-ih3 {
      background-color: var(--graf-ih3);
    }

    .bg-ih4 {
      background-color: var(--graf-ih4);
    }

    code,
    pre {
      padding: 0.5em;
      border-radius: 0.3em;
      display: block;
      overflow-x: auto;
    }

    section {
      margin-block: 2rem;
    }
  </style>

  <!-- Mermaid 10/11 -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.6/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'neutral',
      securityLevel: 'loose',
      layout: 'elk',
      themeVariables: {
        fontFamily: 'monospace',
      }
    });
  </script>

  <!-- MathJax 3 -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\', '\']],
        displayMath: [['$$', '$$'], ['\', '\']],
        colorIsTextColor: true
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-coy.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/prism-typescript.min.js"></script>

</head>

<body>
  <main>
    <h1>Matematyka w Genealogi</h1>
    <p><strong>Systematyczny i spójny model oraz metoda wnioskowania typologii pokrewieństwa.</strong></p>
    <p>Rzeczą oczywistą jest, że wobec różnorodności modeli rodzinnych niezwykle trudne byłoby skonstruowanie systemu,
      który
      mógłby znaleźć zastosowanie inne niż jako ogólny indeks o charakterze pomocniczym. Osoby identyfikowane są za
      pomocą
      imion i nazwisk, zatem nie zachodzi potrzeba przypisywania im sztywnych identyfikatorów – chyba że w ramach
      lokalnych
      systemów bazodanowych, gdzie stosuje się np. GUID lub UUID. Kwestia ta jednak wykracza poza zakres niniejszego
      opracowania.
    </p>
    <p>Jaki zatem cel miałby przyświecać tworzeniu takiego systemu? Główną funkcją systemu pozycyjnego jest umożliwienie
      klasyfikacji typów relacji pokrewieństwa w sposób jednoznaczny i uporządkowany. Dzięki temu możliwe staje się
      precyzyjne
      rozpoznanie, czy dana osoba jest np. bratem cioteczno-stryjecznym, czy też bratem wujeczno-ciotecznym. O ile
      określenie
      bliskich relacji pokrewieństwa nie nastręcza zwykle trudności, o tyle identyfikacja więzi dalszych wymaga już
      systematyzującego narzędzia analitycznego. Takie sprawne, strukturalne porządkowanie osób według rodzaju
      pokrewieństwa
      okazuje się kluczowe zwłaszcza w genealogii genetycznej — w procesach dedukcji potencjalnych relacji, ustalania
      stopnia
      pokrewieństwa oraz w identyfikacji wspólnych fragmentów centy-morganowych dziedziczonych po określonych liniach
      wspólnych
      przodków.
    </p>
    <p><strong>KONSPEKT</strong></p>
    <ol>
      <li><strong>GRAF DRZEWA BINARNEGO (PODSTAWY) </strong> — w tej części bez terMINologii genealogicznej omawiam
        podstawowy
        model, na którym wszystko inne się opiera.
      </li>
      <li><strong>GRAF DRZEWA BINARNEGO (KONCEPCJA LINII) </strong> — w tej części nadal bez terMINologii genealogicznej
        wprowadzam koncepcję linii, bazujac na modelu drzewa binarnego.
      </li>
    </ol>
    <hr />
    <article>
      <h2>1. GRAF DRZEWA BINARNEGO (PODSTAWY)</h2>

      <div class="mermaid">
      ---
      config:
      layout: elk
      look: handDrawn
      theme: neutral
      ---
      graph TD
      1["ROOT <br> 1 →│← 1"]
      1 <--> 2["NODE-L <br> 2 →│← 3"]
      1 <--> 3["NODE-R <br> 3 →│← 2"]
      2 <--> 4["NODE-L <br> 4 →│← 7"]
      2 <--> 5["NODE-R <br> 5 →│← 6"]
      3 <--> 6["NODE-L <br> 6 →│← 5"]
      3 <--> 7["NODE-R <br> 7 →│← 4"]

      style 1 fill:#dd74a0,stroke:#333,stroke-width:1px
      style 2 fill:#d18a23,stroke:#333,stroke-width:1px
      style 3 fill:#d18a23,stroke:#333,stroke-width:1px
      style 4 fill:#9ea329,stroke:#333,stroke-width:1px
      style 5 fill:#9ea329,stroke:#333,stroke-width:1px
      style 6 fill:#9ea329,stroke:#333,stroke-width:1px
      style 7 fill:#9ea329,stroke:#333,stroke-width:1px
      </div>

      <p>
        Drzewo binarne oznaczone etykietami o rozmiarze
        $\text{» } {\color{darkorchid}total} = 7\text{ «}$
        (liczba węzłów w drzewie) i wysokości
        $\text{» } {\color{firebrick}ih} = 2\text{ «}$
        (wysokość/poziom $\text{» } {\color{firebrick}ih} \text{ «}$ drzewa zdefiniowana jako liczba krawędzi lub
        połączeń
        od najwyższego węzła lub węzła głównego (ROOT) do najdalszego węzła liścia) z węzłem głównym, którego wartość
        wynosi 1.
        Powyższe drzewo jest zrównoważone, w ale może nie być posortowane (powinno być).
      </p>

      <section id="section-1-1">
        <h3>
          1.1. Obliczanie
          <span class="ih">ih(</span>
          <span class="i">i</span>
          <span class="ih">)</span>
          <strong>wysokości-poziomu</strong>
          na podstawie indeksu
          <span class="i">i</span>
          .
        </h3>

        <p class="math-box">
          <span class="math">
            $$
            \begin{aligned}
            \color{firebrick}{ih(} \color{mediumblue}{i} \color{firebrick}{)}
            \color{black}{= \lfloor \log_2(} \color{mediumblue}{i} \color{black}{) \rfloor}
            \quad \forall\, \color{mediumblue}{i} \color{black}{\,\in \{ }
            \color{mediumblue}{iLR} \color{black}{,\,} \color{mediumblue}{iRL}\color{black}{ \} \subset \mathbb{N}_{+}}
            \end{aligned}
            $$
          </span>
        </p>
      </section>

      <section id="section-1-2">
        <h3>
          1.2. Różne obliczenia tylko i wyłącznie na podstawie
          <span class="ih">ih(</span>
          <span class="i">i</span>
          <span class="ih">)</span>
          <strong>wysokości-poziomu</strong>
          .
        </h3>

        <p class="math-box">
          <span class="math">
            $$
            \begin{aligned}
            \color{darkorchid}{\text{MAX}(\color{firebrick}{ih(\color{mediumblue}{i})})} = &
            \color{darkorchid}{\text{total}(\color{firebrick}{ih(\color{mediumblue}{i})})} = \\
            & \quad = 2^{({\color{firebrick}{ih}}+1)} - 1
            \quad & \forall \, {\color{firebrick}{ih}} \in \mathbb{N}_{0}
            \\
            \\
            \color{darkorchid}{\text{MIN}(\color{firebrick}{ih(\color{mediumblue}{i})})} = &
            \color{darkorchid}{\text{count}(\color{firebrick}{ih(\color{mediumblue}{i})})} = \\
            & \quad = 2^{\color{firebrick}{ih}}
            \quad & \forall \, {\color{firebrick}{ih}} \in \mathbb{N}_{0} \\
            \\
            \color{darkorchid}{\text{MIX}(\color{firebrick}{ih(\color{mediumblue}{i})})} = &
            \color{darkorchid}{\text{MIN}(\color{firebrick}{ih(\color{mediumblue}{i})})} +
            \color{darkorchid}{\text{MAX}(\color{firebrick}{ih(\color{mediumblue}{i})})} = \\
            = & \, (\color{mediumblue}{iLR} + \color{mediumblue}{iRL}) = \\
            & \quad = 3 \cdot 2^{\color{firebrick}{ih}} - 1
            \quad & \forall \, {\color{firebrick}{ih}} \in \mathbb{N}_{0}
            \end{aligned}
            $$
          </span>
        </p>

        <ul>
          <li>
            <strong>
              <span class="mix">MAX(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
              <span> = </span>
              <span class="mix">total(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
            </strong>
            <span> — określa ilość wszystkich węzłów oraz wartość najwyższego indeksu węzła
              na poziomie danej wysokości.
            </span>
          </li>
          <li>
            <strong>
              <span class="mix">MIN(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
              <span> = </span>
              <span class="mix">count(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
            </strong>
            <span> — określa ilość węzłów na danym poziomie oraz wartość najniższego indeksu węzła.
            </span>
          </li>
          <li>
            <strong>
              <span class="mix">MIX(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
              <span> = </span>
              <span class="mix">MIN(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
              <span> + </span>
              <span class="mix">MAX(</span>
              <span class="ih">ih(</span>
              <span class="i">i</span>
              <span class="ih">)</span>
              <span class="mix">)</span>
              <span> = </span>
              <span class="i">iLR</span>
              <span> + </span>
              <span class="i">iRL</span>
            </strong>
            <span> —wartość stała dla poziomu, suma MIN i MAX lub suma indeksów LR+RL.</span>
          </li>
        </ul>
      </section>

      <section id="section-1-3">
        <h3>
          1.3. Wędrowanie po drzewie.
        </h3>

        <p class="math-box">
          <span class="math">
            $$
            \begin{aligned}
            \color{lightseagreen}{\text{child}_{\text{LEFT}}({\color{mediumblue}{i}})} &=
            \begin{cases}
            2 \cdot {\color{mediumblue}{i}} & \quad \text{dla } {\color{mediumblue}{i}}
            = {\color{mediumblue}{i_{LR}}} \\
            2 \cdot {\color{mediumblue}{i}} + 1 & \quad \text{dla } {\color{mediumblue}{i}}
            = {\color{mediumblue}{i_{RL}}}
            \end{cases}
            \end{aligned}
            $$
          </span>
          <br />
          <span class="math">
            $$
            \begin{aligned}
            \color{lightseagreen}{\text{child}_{\text{RIGHT}}({\color{mediumblue}{i}})} &=
            \begin{cases}
            2 \cdot {\color{mediumblue}{i}} + 1 & \quad \text{dla } {\color{mediumblue}{i}} = \color{mediumblue}{i_{LR}} \\
            2 \cdot {\color{mediumblue}{i}} & \quad \text{dla } {\color{mediumblue}{i}} = \color{mediumblue}{i_{RL}}
            \end{cases}
            \end{aligned}
            $$
          </span>
          <br />
          <span class="math">
            $$
            \begin{aligned}
            \color{lightseagreen}{\text{parent}({\color{mediumblue}{i}})} &=
            \begin{cases}
            \varnothing & \quad \text{dla } {\color{mediumblue}{i}} < 2 \\ \left\lfloor \dfrac{{\color{mediumblue}{i}}}{2}
              \right\rfloor & \quad \text{dla } {\color{mediumblue}{i}} \geq 2 \end{cases} \quad \text{gdzie }
              {\color{mediumblue}{i}} \in \{ \color{mediumblue}{i_{LR}}, \color{mediumblue}{i_{RL}} \} \end{aligned} 
            $$
          </span>
          <br />
          <span class="math">
            $$
            \begin{aligned}
            \color{lightseagreen}{\text{sibling}({\color{mediumblue}{i}})} &=
            \begin{cases}
            \varnothing & \quad \text{dla } {\color{mediumblue}{i}} < 2 \\ {\color{mediumblue}{i}} + 1 & \quad \text{dla }
              {\color{mediumblue}{i}}=\color{mediumblue}{i_{LR}} \land {\color{mediumblue}{i}} \bmod 2=0 \\ {\color{mediumblue}{i}} - 1 &
              \quad \text{dla } {\color{mediumblue}{i}}=\color{mediumblue}{i_{LR}} \land {\color{mediumblue}{i}} \bmod 2=1 \\
              {\color{mediumblue}{i}} - 1 & \quad \text{dla } {\color{mediumblue}{i}}=\color{mediumblue}{i_{RL}} \land
              {\color{mediumblue}{i}} \bmod 2=0 \\ {\color{mediumblue}{i}} + 1 & \quad \text{dla }
              {\color{mediumblue}{i}}=\color{mediumblue}{i_{RL}} \land {\color{mediumblue}{i}} \bmod 2=1 \end{cases} \end{aligned}
            $$
            </span>
        </p>
      </section id="section-1-4">
      <section>
        <h3>
          1.4. Obliczanie indeksu odwrotnego
        </h3>

        <p class="math-box">
          <span class="math">
            $$
            \begin{aligned}
            \color{mediumblue}{i_{RL}(\color{mediumblue}{i_{LR}})} &=
            \color{darkorchid}{mix(\color{firebrick}{ih({\color{mediumblue}{i}})})} - \color{mediumblue}{i_{LR}} \\
            \color{mediumblue}{i_{LR}(\color{mediumblue}{i_{RL}})} &=
            \color{darkorchid}{mix(\color{firebrick}{ih({\color{mediumblue}{i}})})} - \color{mediumblue}{i_{RL}}
            \end{aligned}
            $$
          </span>
        </p>
      </section>

      <section id="section-1-5">
        <h3>
          5. Dodatkowy indeks w obrębie poziomu danej wysokości/poziomu
        </h3>
        <p>
          <span>Uniwersalnym indeksem dokładnie wskazującym na miejsce, po odpowiednim przeliczeniu jest</span>          
          <span class="i">iLR</span> oraz <span class="i">iRL</span>
          <span>, jednakowoż dla wygody, co w pełni z niego już wynika, wprowadzamy</span>
          <span class="i">i<span class="ih">h</span>INC</span>
          <span> oraz </span>
          <span class="i">i<span class="ih">h</span>DEC</span>
          <span>, które w obrębie konkretnego poziomu-wysokości</span>
          <span class="ih">ih</span>
          <span>, wprowadzają indeks lokalny w jegoż obrębie.</span>
        </p>
        <p class="math-box">
          <span class="math">
            $$
            \begin{aligned}
            {\color{mediumblue}{i h INC}} &= {\color{mediumblue}{iLR}} -
            {\color{darkorchid}{MIN({\color{firebrick}{ih({{\color{mediumblue}{i}}})})}}} \\
            {\color{mediumblue}{i h DEC}} &= {\color{mediumblue}{iRL}} -
            {\color{darkorchid}{MIN({\color{firebrick}{ih({{\color{mediumblue}{i}}})})}}}
            \end{aligned}
            $$
          </span>
        </p>
      </section>

      <section id="section-1-6">
        <h3>1.6. Odzwierciedlenie w kodzie TypeScript</h3>
        <pre><code class="language-typescript">
type NodeConstructor&lt;T&gt; = new (node: number, X?: "XM" | "XW") =&gt; T;

class Node {
  ihINC: number; // iLR: number;
  ihDEC: number; // iRL: number;
  ih: number; // lvX: number;
  MAX: number; // MAX: number;
  MIN: number; // MIN: number;
  MIX: number; // MIX: number;
  iRL: number; // XM: number;
  iLR: number; // XW: number;

  constructor(node: number, X: "XM" | "XW" = "XM") {
    if (typeof node !== "number" || !Number.isInteger(node) || node &lt;= 0) {
      throw new Error("Parametr node musi być dodatnią liczbą całkowitą.");
    }
    const height = Math.floor(Math.log2(node));
    const nodeMAX = 1 * Math.pow(2, height + 1) - 1;
    const nodeMIN = 1 * Math.pow(2, height + 0) - 0;
    const nodeMIX = 3 * Math.pow(2, height + 0) - 1;

    const nodeXM = X == "XM" ? node :  nodeMIX - node;
    const nodeXW = X == "XM" ? nodeMIX - node :  node;
    const sortXM_LR = nodeXM - nodeMIN;
    const sortXW_RL = nodeXW - nodeMIN;

    this.ihINC = sortXM_LR;
    this.ihDEC = sortXW_RL;
    this.ih = height;
    this.MAX = nodeMAX;
    this.MIN = nodeMIN;
    this.MIX = nodeMIX;
    this.iLR = nodeXM;
    this.iRL = nodeXW;
  }

  static ofRange&lt;T extends Node&gt;(
    this: NodeConstructor&lt;T&gt;,
    A: number,
    Z: number,
    X: "XM" | "XW" = "XM",
  ): T[] {
    const OUT: T[] = [];
    for (let i = A; i &lt;= Z; i++) {
      OUT.push(new this(i, X));
    }
    return OUT;
  }

  static ofMulti&lt;T extends Node&gt;(
    this: NodeConstructor&lt;T&gt;,
    R: string,
    X: "XM" | "XW" = "XM",
  ): T[] {
    const RANGE = ((input: string): number[] =&gt; {
      const result = new Set&lt;number&gt;();

      for (const token of input.trim().split(" ")) {
        if (!token) continue;

        if (token.includes("..")) {
          const [start, end] = token.split("..").map(Number);
          if (Number.isInteger(start) && Number.isInteger(end)) {
            const step = start &lt;= end ? 1 : -1;
            for (let i = start; step &gt; 0 ? i &lt;= end : i &gt;= end; i += step) {
              result.add(i);
            }
          }
        } else {
          const num = Number(token);
          if (Number.isInteger(num)) {
            result.add(num);
          }
        }
      }

      return [...result].sort((a, b) =&gt; a - b);
    })(R);

    const OUT: T[] = [];
    for (const i of RANGE) {
      OUT.push(new this(i, X));
    }
    return OUT;
  }
}
  </code></pre>
      </section>

      <section id="section-1-7">
        <h3>1.7. Podsumowanie na grafie.</h3>
        <pre class="mermaid">
---
config:
  layout: elk
  look: handDrawn
  theme: neutral
---
graph TD
  01["iLR = 1 <br /> iRL = 1  <br /> ih = 0 <br /> ihINC = 0 <br /> ihDEC = 0 <br /> MAX = 1 <br /> MIN = 1 <br /> MIX = 2"]
  01 <--> 02["iLR = 2 <br /> iRL = 3 <br /> ih = 1 <br /> ihINC = 0 <br /> ihDEC = 1 <br /> MAX = 3 <br /> MIN = 2 <br /> MIX = 5"]
  01 <--> 03["iLR = 3 <br /> iRL = 2 <br /> ih = 1 <br /> ihINC = 1 <br /> ihDEC = 0 <br /> MAX = 3 <br /> MIN = 2 <br /> MIX = 5"]
  02 <--> 04["iLR = 4 <br /> iRL = 7 <br /> ih = 2 <br /> ihINC = 0 <br /> ihDEC = 3 <br /> MAX = 7 <br /> MIN = 4 <br /> MIX = 11"]
  02 <--> 05["iLR = 5 <br /> iRL = 6 <br /> ih = 2 <br /> ihINC = 1 <br /> ihDEC = 2 <br /> MAX = 7 <br /> MIN = 4 <br /> MIX = 11"]
  03 <--> 06["iLR = 6 <br /> iRL = 5 <br /> ih = 2 <br /> ihINC = 2 <br /> ihDEC = 1 <br /> MAX = 7 <br /> MIN = 4 <br /> MIX = 11"]
  03 <--> 07["iLR = 7 <br /> iRL = 4 <br /> ih = 2 <br /> ihINC = 3 <br /> ihDEC = 0 <br /> MAX = 7 <br /> MIN = 4 <br /> MIX = 11"]
  04 <--> 08["iLR = 8 <br /> iRL = 15 <br /> ih = 3 <br /> ihINC = 0 <br /> ihDEC = 7 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  04 <--> 09["iLR = 9 <br /> iRL = 14 <br /> ih = 3 <br /> ihINC = 1 <br /> ihDEC = 6 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  05 <--> 10["iLR = 10 <br /> iRL = 13 <br /> ih = 3 <br /> ihINC = 2 <br /> ihDEC = 5 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  05 <--> 11["iLR = 11 <br /> iRL = 12 <br /> ih = 3 <br /> ihINC = 3 <br /> ihDEC = 4 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  06 <--> 12["iLR = 12 <br /> iRL = 11 <br /> ih = 3 <br /> ihINC = 4 <br /> ihDEC = 3 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  06 <--> 13["iLR = 13 <br /> iRL = 10 <br /> ih = 3 <br /> ihINC = 5 <br /> ihDEC = 2 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  07 <--> 14["iLR = 14 <br /> iRL = 9 <br /> ih = 3 <br /> ihINC = 6 <br /> ihDEC = 1 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]
  07 <--> 15["iLR = 15 <br /> iRL = 8 <br /> ih = 3 <br /> ihINC = 7 <br /> ihDEC = 0 <br /> MAX = 15 <br /> MIN = 8 <br /> MIX = 23"]

  style 01 fill:#dd74a0,stroke:#333,stroke-width:1px
  style 02 fill:#d18a23,stroke:#333,stroke-width:1px
  style 03 fill:#d18a23,stroke:#333,stroke-width:1px
  style 04 fill:#9ea329,stroke:#333,stroke-width:1px
  style 05 fill:#9ea329,stroke:#333,stroke-width:1px
  style 06 fill:#9ea329,stroke:#333,stroke-width:1px
  style 07 fill:#9ea329,stroke:#333,stroke-width:1px
  style 08 fill:#52b36c,stroke:#333,stroke-width:1px
  style 09 fill:#52b36c,stroke:#333,stroke-width:1px
  style 10 fill:#52b36c,stroke:#333,stroke-width:1px
  style 11 fill:#52b36c,stroke:#333,stroke-width:1px
  style 12 fill:#52b36c,stroke:#333,stroke-width:1px
  style 13 fill:#52b36c,stroke:#333,stroke-width:1px
  style 14 fill:#52b36c,stroke:#333,stroke-width:1px
  style 15 fill:#52b36c,stroke:#333,stroke-width:1px
  </pre>
      </section>

    </article><hr />
    <article>
      <h2>2. GRAF DRZEWA BINARNEGO (KONCEPCJA LINII)</h2>
      <strong> LINIE SILNIE LEWE </strong>
      <div class="mermaid">
        ---
        config:
        layout: elk
        look: handDrawn
        theme: neutral
        ---
        graph TD
        1["ROOT <br>iLR=1, iRL=1<br>jLL=2<br>jhLL=0<br>jSortLL=1<br>jhSortLL=0"]
        1 <--> 2["NODE-L <br>iLR=2, iRL=3<br>jLL=2<br>jhLL=1<br>jSortLL=1<br>jhSortLL=0"]
        1 <--> 3["NODE-R <br>iLR=3, iRL=2<br>jLL=4<br>jhLL=0<br>jSortLL=3<br>jhSortLL=1"]
        2 <--> 4["NODE-L <br>iLR=4, iRL=7<br>jLL=2<br>jhLL=2<br>jSortLL=1<br>jhSortLL=0"]
        2 <--> 5["NODE-R <br>iLR=5, iRL=6<br>jLL=6<br>jhLL=0<br>jSortLL=5<br>jhSortLL=2"]
        3 <--> 6["NODE-L <br>iLR=6, iRL=5<br>jLL=4<br>jhLL=1<br>jSortLL=3<br>jhSortLL=1"]
        3 <--> 7["NODE-R <br>iLR=7, iRL=4<br>jLL=8<br>jhLL=0<br>jSortLL=7<br>jhSortLL=2"]

        style 1 fill:#dd74a0,stroke:#333,stroke-width:1px
        style 2 fill:#d18a23,stroke:#333,stroke-width:1px
        style 3 fill:#d18a23,stroke:#333,stroke-width:1px
        style 4 fill:#9ea329,stroke:#333,stroke-width:1px
        style 5 fill:#9ea329,stroke:#333,stroke-width:1px
        style 6 fill:#9ea329,stroke:#333,stroke-width:1px
        style 7 fill:#9ea329,stroke:#333,stroke-width:1px
        </div>
        
        <strong> LINIE SILNIE PRAWE </strong>
        
      <div class="mermaid">
        ---
        config:
        layout: elk
        look: handDrawn
        theme: neutral
        ---
        graph TD
        1["ROOT <br>iLR=1, iRL=1<br>jRR=3<br>jhRR=0<br>jSortRR=1<br>jhSortRR=0"]
        1 <--> 2["NODE-L <br>iLR=2, iRL=3<br>jRR=5<br>jhRR=0<br>jSortRR=3<br>jhSortRR=1"]
        1 <--> 3["NODE-R <br>iLR=3, iRL=2<br>jRR=3<br>jhRR=1<br>jSortRR=1<br>jhSortRR=0"]
        2 <--> 4["NODE-L <br>iLR=4, iRL=7<br>jRR=9<br>jhRR=0<br>jSortRR=7<br>jhSortRR=2"]
        2 <--> 5["NODE-R <br>iLR=5, iRL=6<br>jRR=5<br>jhRR=1<br>jSortRR=3<br>jhSortRR=1"]
        3 <--> 6["NODE-L <br>iLR=6, iRL=5<br>jRR=7<br>jhRR=0<br>jSortRR=5<br>jhSortRR=2"]
        3 <--> 7["NODE-R <br>iLR=7, iRL=4<br>jRR=3<br>jhRR=2<br>jSortRR=1<br>jhSortRR=0"]

        style 1 fill:#dd74a0,stroke:#333,stroke-width:1px
        style 2 fill:#d18a23,stroke:#333,stroke-width:1px
        style 3 fill:#d18a23,stroke:#333,stroke-width:1px
        style 4 fill:#9ea329,stroke:#333,stroke-width:1px
        style 5 fill:#9ea329,stroke:#333,stroke-width:1px
        style 6 fill:#9ea329,stroke:#333,stroke-width:1px
        style 7 fill:#9ea329,stroke:#333,stroke-width:1px
        </div>
        <p>
          Kluczowym aspektem w procesie określania przynależności do danej linii genealogicznej jest zmienna <span
            class="j">j</span>, która wyznacza numer linii, oraz zmienna <span class="jh">jh</span>, wskazująca na położenie w
          pionowej strukturze pokrewieństwa, tj. wysokość poziomu w obrębie tej linii. Zmienne pomocnicze <span
            class="jsort">jSort</span> oraz <span class="jhsort">jhSort</span> pełnią funkcję wspomagającą w porządkowaniu i
          jednoznacznym wyznaczaniu tych relacji, lecz same nie stanowią podstawy klasyfikacyjnej.
        </p>
        
        <section id="section-2-1">
          <h2>2.1 Obliczenia (część 1)</h2>

          <p><strong>WYJAŚNIENIE:</strong> <span style="background-color: white;padding: 0.3rem; border-radius: 0.5rem;">v2(x)</span> to 2-adyczna waluacja liczby całkowitej dodatniej x (liczba zer na końcu binarnej reprezentacji x>0).</p>

          <p class="math-box">
            <span class="math">
              $$
              \begin{aligned}
              {\color{darkgoldenrod}{jhLL({\color{mediumblue}{i}})}} & =
              \begin{cases}
              {\color{firebrick}{ih({\color{mediumblue}{i}})}} 
              & \quad \text{dla } {\color{mediumblue}{iLR}} = 0 \\
              v_2({\color{mediumblue}{iLR}})
              & \quad \text{dla } {\color{mediumblue}{iLR}} \neq 0 \\
              \end{cases} 
              \\\\
              {\color{darkgoldenrod}{jhRR({\color{mediumblue}{i}})}} & =
              \begin{cases} 
              {\color{firebrick}{ih({\color{mediumblue}{i}})}} 
              & \quad \text{dla } {\color{mediumblue}{iRL}} = 0 \\
              v_2({\color{mediumblue}{iRL}})
              & \quad \text{dla } {\color{mediumblue}{iRL}} \neq 0 \\
              \end{cases}
              \end{aligned}
              $$
            </span>
            </p>
        </section>

        <section id="section-2-2">
          <h2>2.2 Obliczenia (część 2)</h2>
        
          <p><strong>WYJAŚNIENIE:</strong> <span
              style="background-color: white;padding: 0.3rem; border-radius: 0.5rem;">v2(x)</span> to 2-adyczna waluacja liczby
            całkowitej dodatniej x (liczba zer na końcu binarnej reprezentacji x>0).</p>
        
          <p class="math-box">
            <span class="math">
              $$
              \begin{aligned}
              {\color{mediumpurple}{jSortLL({\color{mediumblue}{i}})}} & =
              \dfrac{{\color{mediumblue}{iLR}}}{2^{v_2({\color{mediumblue}{iLR}})}} 
              \\\\
              {\color{royalblue}{jLL({\color{mediumblue}{i}})}} & =
              {\color{mediumpurple}{jSortLL({\color{mediumblue}{i}})}} + 1
              \\\\              
              {\color{sienna}{jhSortLL({\color{mediumblue}{i}})}} & = 
              \lfloor \log_2({\color{mediumpurple}{jSortLL({\color{mediumblue}{i}})}}) \rfloor
              \\\\
              {\color{mediumpurple}{jSortRR({\color{mediumblue}{i}})}} & =
              \dfrac{{\color{mediumblue}{iRL}}}{2^{v_2({\color{mediumblue}{iRL}})}} 
              \\\\
              {\color{royalblue}{jRR({\color{mediumblue}{i}})}} & =
              {\color{mediumpurple}{jSortRR({\color{mediumblue}{i}})}} + 2
              \\\\              
              {\color{sienna}{jhSortRR({\color{mediumblue}{i}})}} & = 
              \lfloor \log_2({\color{mediumpurple}{jSortRR({\color{mediumblue}{i}})}}) \rfloor
              \end{aligned}
              $$
            </span>
          </p>
        </section>
        <section id="section-2-3">
          <h3>2.3. Odzwierciedlenie w kodzie TypeScript</h3>
          <pre><code class="language-typescript">
class NodeLine extends Node {
  jhSortLL: number;   //iM: number;    
  jhLL   : number; //lvLM: number;   
  jLL    : number;   //LM: number;    
  jSortLL : number;  //LM_: number;      

  jhSortRR: number;   //iW: number;    
  jhRR   : number; //lvLW: number;   
  jRR    : number;   //LW: number;    
  jSortRR : number;  //LW_: number;   
  
  constructor(node: number, X: &quot;XM&quot; | &quot;XW&quot; = &quot;XM&quot;){
    super(node, X);
    function v2adic(x: number): number {
      if (typeof x !== &quot;number&quot; || !Number.isInteger(x) || x &lt;= 0) {
        throw new Error(&quot;Parametr x musi być dodatnią liczbą całkowitą.&quot;);
      }

      // x &amp; -x to 2^k, więc log2 tego da dokładnie k
      return Math.log2(x &amp; -x);
    }

    function v2adic_precision(x: number): number {
      if (typeof x !== &quot;number&quot; || !Number.isInteger(x) || x &lt;= 0) {
        throw new Error(&quot;Parametr x musi być dodatnią liczbą całkowitą.&quot;);
      }
      let r = 0;
      let t = true;
      const e = Array.from(x.toString(2));
      let l = e.length;
      while (l &gt; 0 &amp;&amp; t) {
        if (e[l - 1] == &quot;0&quot;) {
          r++;
        } else {
          t = false;
        }
        l--;
      }
      return r;
    }

    this.jhLL = (this.iLR == 0 ? this.ih + 1 : v2adic(this.iLR) + 1) - 1;
    this.jhRR = (this.iRL == 0 ? this.ih + 1 : v2adic(this.iRL) + 1) - 1;

    this.jSortLL = this.iLR / Math.pow(2, v2adic(this.iLR));
    this.jSortRR = this.iRL / Math.pow(2, v2adic(this.iRL));

    this.jLL = this.jSortLL + 1;
    this.jRR = this.jSortRR + 2;

    this.jhSortLL = Math.floor(Math.log2(this.jSortLL));
    this.jhSortRR = Math.floor(Math.log2(this.jSortRR));
  }
}
                </code></pre>
        </section>
        
      </article>
  </main>
</body>

</html>
